rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // Helpers
    // ============================================================================
    function isSignedIn() {
      return request.auth != null;
    }


        function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }
    function participantIdsOf(data) {
      // Accept both v2 field (participantIds) and legacy alias (participants).
      // Be null-safe: if data isn't a map (e.g., doc doesn't exist), return [].
      return (data is map) ? (
        (data.participantIds is list) ? data.participantIds :
        (data.participants is list) ? data.participants :
        []
      ) : [];
    }



    function hasTwoParticipants(data) {
      return participantIdsOf(data).size() == 2;
    }

    function isParticipant(data) {
      // For reads/updates, only require that the requester is listed as a participant.
      // Do NOT require size()==2 here, because legacy/corrupt docs would cause false denies.
      return isSignedIn()
        && participantIdsOf(data).hasAny([request.auth.uid]);
    }


    function mapOrEmpty(v) {
      return (v is map) ? v : {};
    }

    function adminUserUpdateAllowed() {
      // Only allow admins to modify specific safe subsets on users/{uid}
      let changedTop = request.resource.data.diff(resource.data).changedKeys();

      // Only these top-level keys may change:
      let topOk =
        changedTop.hasOnly(['dating', 'account']) ||
        changedTop.hasOnly(['dating']) ||
        changedTop.hasOnly(['account']);

      // dating.* allowed keys (admin verification workflow)
      let beforeDating = mapOrEmpty(resource.data.dating);
      let afterDating = mapOrEmpty(request.resource.data.dating);
      let datingChanged = afterDating.diff(beforeDating).changedKeys();

      let datingOk =
        !changedTop.hasAny(['dating']) ||
        datingChanged.hasOnly([
          'verificationStatus',
          'verifiedBy',
          'verifiedAt',
          'reviewedBy',
          'reviewedAt',
          'rejectedAt',
          'rejectionReason'
        ]);

      // account.* allowed keys (admin moderation disable/enable)
      let beforeAcc = mapOrEmpty(resource.data.account);
      let afterAcc = mapOrEmpty(request.resource.data.account);
      let accChanged = afterAcc.diff(beforeAcc).changedKeys();

      let accountOk =
        !changedTop.hasAny(['account']) ||
        accChanged.hasOnly([
          'disabled',
          'disabledBy',
          'disabledAt',
          'disabledReason',
          'isDisabled'
        ]);

      return topOk && datingOk && accountOk;
    }
    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================

    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================
    match /users/{uid} {
      // Read policy:
      // - Signed-in users can read their own doc.
      // - Signed-in users can read other users ONLY if genders are opposite (male<->female).
      // - Optional admin override via custom claim: isAdmin()
      // - Unauthenticated users can query username field for login lookup (must be single equality filter)
      allow read: if isSignedIn() || 
                     (request.query.fieldFilters.size() == 1 && 
                      (request.query.fieldFilters[0].field == 'username' ||
                       request.query.fieldFilters[0].field == 'displayName'));

      allow create: if isSignedIn() && request.auth.uid == uid;

      allow update: if isSignedIn() && (
        request.auth.uid == uid ||
        (isAdmin() && adminUserUpdateAllowed())
      );

      allow delete: if false;

      match /notifications/{notificationId} {
        allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
      }

      match /assessments/{assessmentId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }



    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================

    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    match /nexus2_chats/{chatId} {
  // Allow signed-in users to query their own chats
  // The where('participantIds', arrayContains: userId) query is allowed
  allow list: if isSignedIn();
  
  // Participants can read individual chat documents
  allow read: if isParticipant(resource.data);

  // Create allowed only if you're one of the participants.
  allow create: if isSignedIn()
    && request.resource.data.participantIds is list
    && request.resource.data.participantIds.hasAny([request.auth.uid]);

  // Updates only by participants.
  allow update: if isParticipant(resource.data);

  // No deletes
  allow delete: if false;

  // Messages subcollection
  match /messages/{messageId} {
    allow read, list: if isParticipant(get(/databases/$(database)/documents/nexus2_chats/$(chatId)).data);
    allow create: if isSignedIn()
      && request.resource.data.senderId == request.auth.uid
      && isParticipant(get(/databases/$(database)/documents/nexus2_chats/$(chatId)).data);
    allow update: if isParticipant(get(/databases/$(database)/documents/nexus2_chats/$(chatId)).data);
    allow delete: if false;
  }
}


match /chats/{chatId} {
  // Allow reads even if doc doesn't exist yet (so get() returns not-found rather than deny).
  // Read permission: user is signed in AND is a participant
  allow read: if isSignedIn() && (!(resource.data is map) || isParticipant(resource.data));

  // Allow list/query for signed-in users querying their own conversations.
  // The `where('participantIds', arrayContains: userId)` query is supported and efficient.
  allow list: if isSignedIn();

  // Allow create: Any signed-in user can create a chat.
  // NOTE: Gating for "max 3 free conversations" is enforced at the message-send level
  // via canSendMessage() in SubscriptionService, not at the chat-open level.
  allow create: if isSignedIn();

  // Participants can update
  allow update: if isSignedIn() && isParticipant(resource.data);

  allow delete: if false;

  match /messages/{messageId} {
    function parentChat() {
      return get(/databases/$(database)/documents/chats/$(chatId)).data;
    }

    // Read permission: user is signed in and is a participant
    allow read: if isSignedIn() && (
      !(parentChat() is map) || isParticipant(parentChat())
    );

    // List permission for querying messages in a chat: user is a participant
    allow list: if isSignedIn() && (
      !(parentChat() is map) || isParticipant(parentChat())
    );

    // Only sender can create a message; receiver must be the other participant
    // NOTE: Gating for "max 3 free conversations" will be enforced in the app layer
    // via SubscriptionService.canSendMessage(), NOT in Firestore rules.
    allow create: if isSignedIn()
      && request.resource.data.senderId == request.auth.uid
      && isParticipant(parentChat());

    // Conservative: only receiver updates (mark read) OR sender updates their own message.
    allow update: if isSignedIn()
      && isParticipant(parentChat());

    allow delete: if false;
  }
}

    // ============================================================================
    // Assessments / Journeys / Stories / Polls / Support (as referenced in code)
    // ============================================================================
    match /assessmentResults/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /results/{resultId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /journeyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /progress/{progressId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /responses/{responseId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /storyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /stories/{storyId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
      }
    }

    match /pollAggregates/{pollId} {
      allow read: if true;
      allow create, update: if isSignedIn();
      allow delete: if false;
    }

    match /pollVotes/{pollId} {
      allow read: if isSignedIn();
      allow write: if false;
      match /votes/{voteId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if false;
      }
    }

    match /supportRequests/{requestId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }

    // Public content (read-only)
    match /stories/{storyId} {
      allow read: if true;
      allow write: if false;
    }

    match /journeys/{journeyId} {
      allow read: if true;
      allow write: if false;
    }

    // Story engagement/comments/likes
    match /storyEngagement/{storyId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if false;
    }

    match /storyComments/{storyId}/comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    match /storyLikes/{storyId}/likes/{likeId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow update: if false;
    }

    // datingProfiles referenced by dating_profile_status_provider.dart
    match /datingProfiles/{uid} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && request.auth.uid == uid;
      allow delete: if false;
    }

    // ============================================================================
    // Content Management System (CMS) - Remote stories & polls
    // ============================================================================
    match /cms/{document=**} {
      // Public read-only access to stories, polls, and versions
      allow read: if true;
      // Admin write access only
      allow write: if isAdmin();
    }

    // ============================================================================
    // User Reports & Moderation
    // ============================================================================
    match /reports/{reportId} {
      // Admins can read all reports
      allow read: if isAdmin();
      
      // Signed-in users can submit reports
      allow create: if isSignedIn() && request.resource.data.reporterKey == request.auth.uid;
      
      // Only admins can update/delete (for status changes and cleanup)
      allow update, delete: if isAdmin();
    }

    // ============================================================================
    // Default deny
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
