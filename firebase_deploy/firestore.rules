// NOTE: This file is a mirror of firebase_deploy/firebase_deploy/firestore.rules
// Source of truth for deployment lives in firebase_deploy/firebase_deploy/ (see firebase.json).

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // Helpers
    // ============================================================================
    function isSignedIn() {
      return request.auth != null;
    }

    function normGender(g) {
      return g == null ? '' : g.toLowerCase();
    }

    function isOppositeGender(uid1, uid2) {
      let u1 = get(/databases/$(database)/documents/users/$(uid1)).data;
      let u2 = get(/databases/$(database)/documents/users/$(uid2)).data;

      let g1 = normGender(u1.gender);
      let g2 = normGender(u2.gender);

      return (g1 == 'male' && g2 == 'female') || (g1 == 'female' && g2 == 'male');
    }

    function hasTwoParticipants(data) {
      return data.participantIds is list && data.participantIds.size() == 2;
    }

    function isParticipant(data) {
      return isSignedIn()
        && hasTwoParticipants(data)
        && data.participantIds.hasAny([request.auth.uid]);
    }


    function mapOrEmpty(v) {
      return (v is map) ? v : {};
    }

    function adminUserUpdateAllowed() {
      // Only allow admins to modify specific safe subsets on users/{uid}
      let changedTop = request.resource.data.diff(resource.data).changedKeys();

      // Only these top-level keys may change:
      let topOk =
        changedTop.hasOnly(['dating', 'account']) ||
        changedTop.hasOnly(['dating']) ||
        changedTop.hasOnly(['account']);

      // dating.* allowed keys (admin verification workflow)
      let beforeDating = mapOrEmpty(resource.data.dating);
      let afterDating = mapOrEmpty(request.resource.data.dating);
      let datingChanged = afterDating.diff(beforeDating).changedKeys();

      let datingOk =
        !changedTop.hasAny(['dating']) ||
        datingChanged.hasOnly([
          'verificationStatus',
          'verifiedBy',
          'verifiedAt',
          'reviewedBy',
          'reviewedAt',
          'rejectedAt',
          'rejectionReason'
        ]);

      // account.* allowed keys (admin moderation disable/enable)
      let beforeAcc = mapOrEmpty(resource.data.account);
      let afterAcc = mapOrEmpty(request.resource.data.account);
      let accChanged = afterAcc.diff(beforeAcc).changedKeys();

      let accountOk =
        !changedTop.hasAny(['account']) ||
        accChanged.hasOnly([
          'disabled',
          'disabledBy',
          'disabledAt',
          'disabledReason',
          'isDisabled'
        ]);

      return topOk && datingOk && accountOk;
    }
    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================

    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================
    match /users/{uid} {
      // Read policy:
      // - Signed-in users can read their own doc.
      // - Signed-in users can read other users ONLY if genders are opposite (male<->female).
      // - Optional admin override via custom claim: request.auth.token.admin == true
      allow read: if isSignedIn() && (
        request.auth.uid == uid ||
        (request.auth.token.admin == true) ||
        isOppositeGender(request.auth.uid, uid)
      );

      allow create: if isSignedIn() && request.auth.uid == uid;

      allow update: if isSignedIn() && (
        request.auth.uid == uid ||
        (request.auth.token.admin == true && adminUserUpdateAllowed())
      );

      allow delete: if false;

      match /notifications/{notificationId} {
        allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
      }

      match /assessments/{assessmentId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }



    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================

    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    match /nexus2_chats/{chatId} {
      allow read: if isParticipant(resource.data);

      allow create: if isSignedIn()
        && hasTwoParticipants(request.resource.data)
        && request.resource.data.participantIds.hasAny([request.auth.uid])
        && isOppositeGender(
          request.resource.data.participantIds[0],
          request.resource.data.participantIds[1]
        );

      allow update, delete: if isParticipant(resource.data);

      match /messages/{messageId} {
        function parentChat() {
          return get(/databases/$(database)/documents/nexus2_chats/$(chatId)).data;
        }

        allow read: if isParticipant(parentChat());

        // Only sender can create messages, and receiver must be the other participant.
        allow create: if isSignedIn()
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.receiverId != request.auth.uid
          && request.resource.data.receiverId in parentChat().participantIds
          && isParticipant(parentChat());

        // Only receiver can update (e.g., mark read). No deletes from clients.
        allow update: if isSignedIn()
          && request.auth.uid == resource.data.receiverId
          && isParticipant(parentChat());

        allow delete: if false;
      }
    }





    // ============================================================================
    // Legacy v1 Chats (still referenced in subscription_service.dart)
    // NOTE: assumes chats docs have participantIds like v2.
    // ============================================================================
    match /chats/{chatId} {
      allow read: if isParticipant(resource.data);

      allow create: if isSignedIn()
        && hasTwoParticipants(request.resource.data)
        && request.resource.data.participantIds.hasAny([request.auth.uid]);

      allow update, delete: if isParticipant(resource.data);

      match /messages/{messageId} {
        function parentChat() {
          return get(/databases/$(database)/documents/chats/$(chatId)).data;
        }

        allow read: if isParticipant(parentChat());

        allow create: if isSignedIn()
          && request.resource.data.senderId == request.auth.uid
          && isParticipant(parentChat());

        allow update, delete: if isSignedIn()
          && request.auth.uid == resource.data.senderId
          && isParticipant(parentChat());
      }
    }

    // ============================================================================
    // Assessments / Journeys / Stories / Polls / Support (as referenced in code)
    // ============================================================================
    match /assessmentResults/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /results/{resultId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /journeyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /progress/{progressId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /responses/{responseId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /storyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /stories/{storyId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
      }
    }

    match /pollAggregates/{pollId} {
      allow read: if true;
      allow write: if false;
    }

    match /pollVotes/{pollId} {
      allow read: if isSignedIn();
      allow write: if false;
      match /votes/{voteId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if false;
      }
    }

    match /supportRequests/{requestId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }

    // Public content (read-only)
    match /stories/{storyId} {
      allow read: if true;
      allow write: if false;
    }

    match /journeys/{journeyId} {
      allow read: if true;
      allow write: if false;
    }

    // Story engagement/comments/likes
    match /storyEngagement/{storyId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    match /storyComments/{storyId}/comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    match /storyLikes/{storyId}/likes/{likeId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow update: if false;
    }

    // datingProfiles referenced by dating_profile_status_provider.dart
    match /datingProfiles/{uid} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && request.auth.uid == uid;
      allow delete: if false;
    }

    // ============================================================================
    // Default deny
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
