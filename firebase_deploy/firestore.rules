rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ============================================================================
    // Helpers
    // ============================================================================
    function isSignedIn() {
      return request.auth != null;
    }


        function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }
    function participantIdsOf(data) {
      // Accept both v2 field (participantIds) and legacy alias (participants).
      // Be null-safe: if data isn't a map (e.g., doc doesn't exist), return [].
      return (data is map) ? (
        (data.participantIds is list) ? data.participantIds :
        (data.participants is list) ? data.participants :
        []
      ) : [];
    }



    function hasTwoParticipants(data) {
      return participantIdsOf(data).size() == 2;
    }

    function isParticipant(data) {
      // For reads/updates, only require that the requester is listed as a participant.
      // Do NOT require size()==2 here, because legacy/corrupt docs would cause false denies.
      return isSignedIn()
        && participantIdsOf(data).hasAny([request.auth.uid]);
    }


    function mapOrEmpty(v) {
      return (v is map) ? v : {};
    }

    function adminUserUpdateAllowed() {
      // Only allow admins to modify specific safe subsets on users/{uid}
      let changedTop = request.resource.data.diff(resource.data).changedKeys();

      // Only these top-level keys may change:
      let topOk =
        changedTop.hasOnly(['dating', 'account']) ||
        changedTop.hasOnly(['dating']) ||
        changedTop.hasOnly(['account']);

      // dating.* allowed keys (admin verification workflow)
      let beforeDating = mapOrEmpty(resource.data.dating);
      let afterDating = mapOrEmpty(request.resource.data.dating);
      let datingChanged = afterDating.diff(beforeDating).changedKeys();

      let datingOk =
        !changedTop.hasAny(['dating']) ||
        datingChanged.hasOnly([
          'verificationStatus',
          'verifiedBy',
          'verifiedAt',
          'reviewedBy',
          'reviewedAt',
          'rejectedAt',
          'rejectionReason'
        ]);

      // account.* allowed keys (admin moderation disable/enable)
      let beforeAcc = mapOrEmpty(resource.data.account);
      let afterAcc = mapOrEmpty(request.resource.data.account);
      let accChanged = afterAcc.diff(beforeAcc).changedKeys();

      let accountOk =
        !changedTop.hasAny(['account']) ||
        accChanged.hasOnly([
          'disabled',
          'disabledBy',
          'disabledAt',
          'disabledReason',
          'isDisabled'
        ]);

      return topOk && datingOk && accountOk;
    }
    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================

    // ============================================================================
    // USERS (v1 + v2 share the same collection)
    // ============================================================================
    match /users/{uid} {
      // Read policy:
      // - Signed-in users can read their own doc.
      // - Signed-in users can read other users ONLY if genders are opposite (male<->female).
      // - Optional admin override via custom claim: isAdmin()
      allow get: if isSignedIn();
      
      // List policy: Allow username lookups for login (unauthenticated users need this)
      // Note: This is for login flow where users query by username to get email
      allow list: if true;

      allow create: if isSignedIn() && request.auth.uid == uid;

      allow update: if isSignedIn() && (
        request.auth.uid == uid ||
        (isAdmin() && adminUserUpdateAllowed())
      );

      allow delete: if false;

      match /notifications/{notificationId} {
        allow read, create, update, delete: if isSignedIn() && request.auth.uid == uid;
      }

      match /assessments/{assessmentId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }



    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================

    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    // ============================================================================
    // Nexus v2 Chats (strict + opposite gender enforced)
    // ============================================================================
    match /nexus2_chats/{chatId} {
      // GET: allow signed-in users to read chat docs (including checking if doc exists during create)
      allow get: if isSignedIn();

      // LIST: allow signed-in users to list their chats
      allow list: if isSignedIn();

      // CREATE: Allow any signed-in user to create chats (v2024-01-22)
      allow create: if isSignedIn();

      // UPDATE: Only participants can update chat metadata
      allow update: if isSignedIn() && isParticipant(resource.data);

      allow delete: if false;

      match /messages/{messageId} {
        function parentChat() {
          return get(/databases/$(database)/documents/nexus2_chats/$(chatId)).data;
        }

        // READ: Allow participants to read messages in their chats
        allow read: if isSignedIn() && (
          !(parentChat() is map) || isParticipant(parentChat())
        );

        // CREATE: Strict validation - only sender can create, must be participant
        allow create: if isSignedIn()
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.receiverId != request.auth.uid
          && request.resource.data.receiverId in participantIdsOf(parentChat())
          && isParticipant(parentChat());

        // UPDATE: Only receiver can update (mark as read)
        allow update: if isSignedIn()
          && request.auth.uid == resource.data.receiverId
          && isParticipant(parentChat());

        allow delete: if false;
      }
    }

match /chats/{chatId} {
  // Allow reads for signed-in participants.
  // If the doc doesn't exist yet, Firestore returns null for resource.data, which is not a map,
  // so !(resource.data is map) returns true, allowing the read.
  allow read: if isSignedIn() && (!(resource.data is map) || isParticipant(resource.data));

  // Allow list/query for signed-in users querying their own conversations.
  // The `where('participantIds', arrayContains: userId)` query is supported and efficient.
  allow list: if isSignedIn();

  // Allow create: Any signed-in user can create a chat.
  // NOTE: Gating for "max 3 free conversations" is enforced ONLY at message-send level
  // via canSendMessage() in SubscriptionService, NOT at the chat-open level.
  allow create: if isSignedIn();

  // Participants can update
  allow update: if isSignedIn() && isParticipant(resource.data);

  allow delete: if false;

  match /messages/{messageId} {
    function parentChat() {
      return get(/databases/$(database)/documents/chats/$(chatId)).data;
    }

    // Read permission: user is signed in and is a participant
    allow read: if isSignedIn() && (
      !(parentChat() is map) || isParticipant(parentChat())
    );

    // List permission for querying messages in a chat: user is a participant
    allow list: if isSignedIn() && (
      !(parentChat() is map) || isParticipant(parentChat())
    );

    // Only sender can create a message; receiver must be the other participant
    // NOTE: Gating for "max 3 free conversations" is enforced ONLY at message-send level
    // via canSendMessage() in SubscriptionService, NOT in Firestore rules.
    allow create: if isSignedIn()
      && request.resource.data.senderId == request.auth.uid
      && isParticipant(parentChat());

    // Conservative: only receiver updates (mark read) OR sender updates their own message.
    allow update: if isSignedIn()
      && isParticipant(parentChat());

    allow delete: if false;
  }
}

    // ============================================================================
    // Assessments / Journeys / Stories / Polls / Support (as referenced in code)
    // ============================================================================
    match /assessmentResults/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /results/{resultId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /history/{historyId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /journeyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /progress/{progressId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
        match /responses/{responseId} {
          allow read, write: if isSignedIn() && request.auth.uid == uid;
        }
      }
    }

    match /storyProgress/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
      match /stories/{storyId} {
        allow read, write: if isSignedIn() && request.auth.uid == uid;
      }
    }

    match /pollAggregates/{pollId} {
      allow read: if true;
      allow write: if false;
    }

    match /pollVotes/{pollId} {
      allow read: if isSignedIn();
      allow write: if false;
      match /votes/{voteId} {
        allow read: if isSignedIn();
        allow create: if isSignedIn();
        allow update, delete: if false;
      }
    }

    match /supportRequests/{requestId} {
      allow create: if isSignedIn();
      allow read, update, delete: if false;
    }

    // Public content (read-only)
    match /stories/{storyId} {
      allow read: if true;
      allow write: if false;
    }

    match /journeys/{journeyId} {
      allow read: if true;
      allow write: if false;
    }

    // Story engagement/comments/likes
    match /storyEngagement/{storyId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    match /storyComments/{storyId}/comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }

    match /storyLikes/{storyId}/likes/{likeId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow update: if false;
    }

    // Comment likes for threaded comment system
    match /storyCommentLikes/{storyId}/likes/{likeId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && likeId.matches('^[^:]+:' + request.auth.uid + '$');
      allow delete: if isSignedIn() && likeId.matches('^[^:]+:' + request.auth.uid + '$');
      allow update: if false;
    }

    // datingProfiles referenced by dating_profile_status_provider.dart
    match /datingProfiles/{uid} {
      allow read: if isSignedIn();
      allow create, update: if isSignedIn() && request.auth.uid == uid;
      allow delete: if false;
    }

    // ============================================================================
    // Content Management System (CMS) - Remote stories & polls (PUBLIC READ)
    // ============================================================================
    match /cms/{document=**} {
      // All users can read stories, polls, versions
      allow read: if true;
      // Only admins can write (for update script)
      allow write: if isAdmin();
    }

    // ============================================================================
    // Default deny
    // ============================================================================
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
