import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';

/// Chat message model
class ChatMessage {
  final String id;
  final String chatId;
  final String senderId;
  final String receiverId;
  final String content;
  final MessageType type;
  final DateTime sentAt;
  final DateTime? readAt;
  final bool isRead;
  final Map<String, dynamic>? metadata;

  const ChatMessage({
    required this.id,
    required this.chatId,
    required this.senderId,
    required this.receiverId,
    required this.content,
    this.type = MessageType.text,
    required this.sentAt,
    this.readAt,
    this.isRead = false,
    this.metadata,
  });

  factory ChatMessage.fromFirestore(Map<String, dynamic> data, String id) {
    return ChatMessage(
      id: id,
      chatId: data['chatId'] as String? ?? '',
      senderId: data['senderId'] as String? ?? '',
      receiverId: data['receiverId'] as String? ?? '',
      content: data['content'] as String? ?? '',
      type: MessageType.fromString(data['type'] as String?),
      sentAt: (data['sentAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      readAt: (data['readAt'] as Timestamp?)?.toDate(),
      isRead: data['isRead'] as bool? ?? false,
      metadata: data['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'chatId': chatId,
      'senderId': senderId,
      'receiverId': receiverId,
      'content': content,
      'type': type.name,
      'sentAt': FieldValue.serverTimestamp(),
      'readAt': readAt != null ? Timestamp.fromDate(readAt!) : null,
      'isRead': isRead,
      'metadata': metadata,
    };
  }

  ChatMessage copyWith({
    String? id,
    String? chatId,
    String? senderId,
    String? receiverId,
    String? content,
    MessageType? type,
    DateTime? sentAt,
    DateTime? readAt,
    bool? isRead,
    Map<String, dynamic>? metadata,
  }) {
    return ChatMessage(
      id: id ?? this.id,
      chatId: chatId ?? this.chatId,
      senderId: senderId ?? this.senderId,
      receiverId: receiverId ?? this.receiverId,
      content: content ?? this.content,
      type: type ?? this.type,
      sentAt: sentAt ?? this.sentAt,
      readAt: readAt ?? this.readAt,
      isRead: isRead ?? this.isRead,
      metadata: metadata ?? this.metadata,
    );
  }
}

enum MessageType {
  text,
  image,
  audio,
  video,
  file,
  system;

  static MessageType fromString(String? value) {
    return MessageType.values.firstWhere(
      (e) => e.name == value,
      orElse: () => MessageType.text,
    );
  }
}

/// Chat conversation model (metadata for a chat between two users)
class ChatConversation {
  final String id;
  final List<String> participantIds;
  final String? lastMessage;
  final DateTime? lastMessageAt;
  final String? lastMessageSenderId;
  final Map<String, int> unreadCounts;
  final Map<String, DateTime?> lastReadAt;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final bool isActive;

  const ChatConversation({
    required this.id,
    required this.participantIds,
    this.lastMessage,
    this.lastMessageAt,
    this.lastMessageSenderId,
    this.unreadCounts = const {},
    this.lastReadAt = const {},
    required this.createdAt,
    this.updatedAt,
    this.isActive = true,
  });

  factory ChatConversation.fromFirestore(Map<String, dynamic> data, String id) {
    // Normalize participants across possible schemas.
    final p = <String>{};

    void addStr(dynamic v) {
      if (v is String) {
        final t = v.trim();
        if (t.isNotEmpty) p.add(t);
      }

  String getOtherParticipantId(String myUserId) {
    final me = myUserId.trim();
    if (me.isEmpty) return '';

    // Primary: participantIds
    for (final id in participantIds) {
      final t = id.trim();
      if (t.isNotEmpty && t != me) return t;
    }

    // Fallback: if stored in other fields (defensive)
    final all = <String>{};
    all.addAll(participantIds.map((e) => e.trim()).where((e) => e.isNotEmpty));

    for (final id in all) {
      if (id != me) return id;
    }

    return '';

  }

    }

    void addList(dynamic v) {
      if (v is List) {
        for (final e in v) {
          addStr(e);
        }
      }
    }

    void addMapKeys(dynamic v) {
      if (v is Map) {
        for (final k in v.keys) {
          addStr(k);
        }
      }
    }

    // New schema: participantIds
    addList(data['participantIds']);
    addMapKeys(data['participantIds']);

    // Legacy schema: participants can be list or map keyed by uid
    addList(data['participants']);
    addMapKeys(data['participants']);

    // Other legacy shapes
    addList(data['memberIds']);
    addList(data['members']);
    addMapKeys(data['members']);

    addStr(data['userId1']);
    addStr(data['userId2']);

    final participants = p.toList();

    return ChatConversation(
      id: id,
      participantIds: participants,
      // keep other fields as they were before (best effort)
      lastMessage: data['lastMessage'] as String? ?? '',
      lastMessageAt: (data['lastMessageAt'] as Timestamp?)?.toDate(),
      isActive: data['isActive'] as bool? ?? true,
      unreadCounts: (data['unreadCounts'] is Map)
          ? Map<String, int>.fromEntries(
              (data['unreadCounts'] as Map).entries.map((e) {
                final k = e.key?.toString() ?? '';
                final v = e.value;
                final n = (v is num) ? v.toInt() : 0;
                return MapEntry(k, n);
              }),
            )
          : const <String, int>{},
      lastReadAt: (data['lastReadAt'] is Map)
          ? Map<String, DateTime?>.fromEntries(
              (data['lastReadAt'] as Map).entries.map((e) {
                final k = e.key?.toString() ?? '';
                final v = e.value;
                if (v is Timestamp) return MapEntry(k, v.toDate());
                return MapEntry(k, null);
              }),
            )
          : const <String, DateTime?>{},
      typingUserIds: List<String>.from(data['typingUserIds'] as List? ?? const []),
    );

  }

  Map<String, dynamic> toFirestore() {
    return {
      'participantIds': participantIds,
      'lastMessage': lastMessage,
      'lastMessageAt':
          lastMessageAt != null ? Timestamp.fromDate(lastMessageAt!) : null,
      'lastMessageSenderId': lastMessageSenderId,
      'unreadCounts': unreadCounts,
      'lastReadAt': lastReadAt.map(
        (key, value) =>
            MapEntry(key, value != null ? Timestamp.fromDate(value) : null),
      ),
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': FieldValue.serverTimestamp(),
      'isActive': isActive,
    };
  }

  /// Get the other participant's ID
  String getOtherParticipantId(String currentUserId) {
    return participantIds.firstWhere(
      (id) => id != currentUserId,
      orElse: () => '',
    );
  }

  /// Get unread count for a user
  int getUnreadCount(String userId) {
    return unreadCounts[userId] ?? 0;
  }
}

/// Service for managing chat functionality
class ChatService {
  static const int _kFreeChatPartnerLimit = 3;

  // ============================================================================
  // PREMIUM CHECK
  // ============================================================================
  Future<bool> _isPremiumUser(String uid) async {
    try {
      final doc = await _fs.collection('users').doc(uid).get();
      final data = doc.data();
      if (data == null) return false;

      bool flag(String k) => (data[k] == true);

      return flag('isPremium') ||
          flag('premium') ||
          flag('subscriptionActive') ||
          flag('hasActiveSubscription');
    } catch (_) {
      // Fail-closed: treat as not premium.
      return false;
    }
  }

  // ============================================================================
  // FREE-TIER GATING (SEND-TIME ONLY)
  //
  // Rule:
  // - Free users can OPEN chats with anyone (createConversation allowed).
  // - Free users can SEND messages to ONLY ONE partner.
  // - Lock happens on FIRST message send.
  //
  // Storage:
  // - users/{uid}.chat.freeChatPartnerId
  // ============================================================================
  Future<void> _enforceFreeTierOnSend({
    required String senderId,
    required String receiverId,
  }) async {
    // Enforce free-tier chat partner limit ONLY when sending a message.
    // Storage:
    // - users/{uid}.chat.freeChatPartnerIds : List<String> (preferred)
    // - users/{uid}.chat.freeChatPartnerId  : String (legacy fallback)
    //
    // Behavior for free users:
    // - If receiverId is already in the allowed list => allow
    // - Else if list has room (< limit) => add receiverId and allow
    // - Else => throw a friendly ChatException

    final isPremium = await _isPremiumUser(senderId);
    if (isPremium) return;

    if (senderId.trim().isEmpty || receiverId.trim().isEmpty) {
      // Be safe: if ids are missing, don't enforce here; the send will fail elsewhere anyway.
      return;
    }

    final meRef = _fs.collection('users').doc(senderId);

    await _fs.runTransaction((tx) async {
      final snap = await tx.get(meRef);
      final meData = snap.data();

      final chatMap =
          (meData?['chat'] is Map) ? (meData!['chat'] as Map) : null;

      // Preferred list field
      List<String> freeList = <String>[];
      final rawList = chatMap?['freeChatPartnerIds'];
      if (rawList is List) {
        freeList =
            rawList
                .map((e) => e.toString().trim())
                .where((e) => e.isNotEmpty)
                .toList();
      }

      // Backward-compat: if list empty, try legacy single id
      if (freeList.isEmpty) {
        final legacy1 = chatMap?['freeChatPartnerId']?.toString().trim();
        if (legacy1 != null && legacy1.isNotEmpty) {
          freeList = [legacy1];
        } else {
          final legacy2 = meData?['freeChatPartnerId']?.toString().trim();
          if (legacy2 != null && legacy2.isNotEmpty) {
            freeList = [legacy2];
          }
        }
      }

      // Normalize: unique + no empties
      freeList =
          freeList.toSet().toList()..removeWhere((e) => e.trim().isEmpty);

      final alreadyAllowed = freeList.contains(receiverId);

      if (!alreadyAllowed) {
        if (freeList.length >= _kFreeChatPartnerLimit) {
          throw ChatException(
            'Premium required: you can only chat with $_kFreeChatPartnerLimit people for free. Subscribe to chat with more people.',
          );
        }

        freeList.add(receiverId);
        freeList =
            freeList.toSet().toList()..removeWhere((e) => e.trim().isEmpty);

        tx.set(meRef, {
          'chat': <String, dynamic>{'freeChatPartnerIds': freeList},
        }, SetOptions(merge: true));

        // Optional: clean up legacy single field (keep if you still rely on it elsewhere)
        // tx.set(meRef, {'chat': <String, dynamic>{'freeChatPartnerId': FieldValue.delete()}}, SetOptions(merge: true));
      }
    });
  }

  FirebaseFirestore? _firestore;

  FirebaseFirestore get _fs =>
      _firestore ?? (throw StateError('Firestore not ready'));
  ChatService({FirebaseFirestore? firestore}) : _firestore = firestore;

  // Collection references
  CollectionReference<Map<String, dynamic>> get _chatsRef =>
      _fs.collection('nexus2_chats');

  CollectionReference<Map<String, dynamic>> _messagesRef(String chatId) =>
      _chatsRef.doc(chatId).collection('messages');

  // ============================================================================
  // ACCOUNT DISABLED GUARDS
  // ============================================================================
  Future<bool> _isUserDisabled(String uid) async {
    final doc = await _fs.collection('users').doc(uid).get();
    final data = doc.data();
    if (data == null) return false;

    // v2 canonical disable flag
    final account = (data['account'] is Map) ? (data['account'] as Map) : null;
    final isDisabled = account?['isDisabled'];
    if (isDisabled == true) return true;

    // Legacy fallbacks (safe for older docs)
    final accountStatus = data['accountStatus']?.toString().toLowerCase();
    if (accountStatus == 'disabled') return true;

    final status = data['status']?.toString().toLowerCase();
    if (status == 'disabled') return true;

    final disabled = data['disabled'];
    if (disabled == true) return true;

    return false;
  }

  Future<void> _assertUsersNotDisabled(List<String> uids) async {
    for (final uid in uids) {
      if (await _isUserDisabled(uid)) {
        throw ChatException('Account disabled by admin');
      }
    }
  }

  // ============================================================================

  // ============================================================================
  // GENDER GUARDS
  // ============================================================================
  String? _normalizeGender(dynamic value) {
    final s = value?.toString().trim().toLowerCase();
    if (s == null || s.isEmpty) return null;

    // Accept v1/v2 variants by normalization.
    if (s == 'male') return 'male';
    if (s == 'female') return 'female';

    return null;
  }

  Future<void> _assertOppositeGender(String userId1, String userId2) async {
    final d1 = await _fs.collection('users').doc(userId1).get();
    final d2 = await _fs.collection('users').doc(userId2).get();

    final m1 = d1.data();
    final m2 = d2.data();

    // v1 stores gender at root: users/{uid}.gender (often "Male"/"Female")
    final g1 = _normalizeGender(m1?['gender']);
    final g2 = _normalizeGender(m2?['gender']);

    final isOpposite =
        (g1 == 'male' && g2 == 'female') || (g1 == 'female' && g2 == 'male');

    // Strict product rule: only male<->female chats are allowed.
    // Unknown/missing genders are rejected.
    if (!isOpposite) {
      throw ChatException(
        'You can only start chats with users of the opposite gender.',
      );
    }
  }

  // CONVERSATION MANAGEMENT
  // ============================================================================

  /// Create a new chat conversation between two users
  /// Returns the chat ID

  /// Create or open a chat conversation between two users.
  ///
  /// Deterministic chatId: "<smallerUid>_<largerUid>".
  /// Premium rule (v2): free users can chat with only ONE partner.
  /// We enforce this WITHOUT querying nexus2_chats (queries can be denied by rules).
  Future<String> createConversation(String userId1, String userId2) async {
    final a = userId1.trim();
    final b = userId2.trim();
    if (a.isEmpty || b.isEmpty) {
      throw ChatException('Invalid user id(s).');
    }
    if (a == b) {
      throw ChatException('You cannot start a chat with yourself.');
    }

    final ids = <String>[a, b]..sort();
    final chatId = '${ids[0]}_${ids[1]}';

    final chatRef = _chatsRef.doc(chatId);
    final meRef = _fs.collection('users').doc(a);

    final chatDoc = <String, dynamic>{
      'participantIds': ids,
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
      'lastMessageAt': FieldValue.serverTimestamp(),
      'lastMessagePreview': '',
      'unreadCounts': <String, dynamic>{ids[0]: 0, ids[1]: 0},
      'isActive': true,
    };

    try {
      await _assertUsersNotDisabled([a, b]);
      await _assertOppositeGender(a, b);

      return await _fs.runTransaction((tx) async {
        final existing = await tx.get(chatRef);
        if (existing.exists) return chatId;

        // Premium detection from *user doc* (transaction-safe).
        final meSnap = await tx.get(meRef);
        final meData = meSnap.data();

        bool flag(String k) => (meData?[k] == true);
        final isPremium =
            flag('isPremium') ||
            flag('premium') ||
            flag('subscriptionActive') ||
            flag('hasActiveSubscription');

        if (!isPremium) {
          // Read lock from either users/{uid}.chat.freeChatPartnerId (preferred)
          // or legacy users/{uid}.freeChatPartnerId.
          final chatMap =
              (meData?['chat'] is Map) ? (meData?['chat'] as Map) : null;

          String? freePartner =
              chatMap?['freeChatPartnerId']?.toString().trim();
          if (freePartner != null && freePartner.isEmpty) freePartner = null;

          freePartner ??= meData?['freeChatPartnerId']?.toString().trim();
          if (freePartner != null && freePartner.isEmpty) freePartner = null;

          if (freePartner != null && freePartner != b) {
            throw ChatException(
          }

          // First-time lock: set free partner id on initiator.
          if (freePartner == null) {
            tx.set(meRef, {
              'chat': {'freeChatPartnerId': b},
            }, SetOptions(merge: true));
          }
        }

        tx.set(chatRef, chatDoc);
        return chatId;
      });
    } catch (e) {
      debugPrint(
        '[CHAT][createConversation] FAILED chatId=$chatId a=$a b=$b error=$e',
      rethrow;
    }
  }

  /// Get conversation between two users
  Future<ChatConversation?> getConversationBetween(
    String userId1,
    String userId2,
  ) async {
    try {
      final sortedIds = [userId1, userId2]..sort();

      final query =
          await _chatsRef
              .where('participantIds', isEqualTo: sortedIds)
              .limit(1)
              .get();

      if (query.docs.isEmpty) return null;

      return ChatConversation.fromFirestore(
        query.docs.first.data(),
        query.docs.first.id,
    } catch (e) {
      debugPrint('Error getting conversation: $e');
      return null;
    }
  }

  /// Get conversation by ID
  Future<ChatConversation?> getConversation(String chatId) async {
    try {
      final doc = await _chatsRef.doc(chatId).get();
      if (!doc.exists || doc.data() == null) return null;
      return ChatConversation.fromFirestore(doc.data()!, doc.id);
    } catch (e) {
      debugPrint('Error getting conversation: $e');
      return null;
    }
  }

  /// Get all conversations for a user
  Future<List<ChatConversation>> getUserConversations(String userId) async {
    try {
      final query =
          await _chatsRef
              .where('participantIds', arrayContains: userId)
              .where('isActive', isEqualTo: true)
              .orderBy('lastMessageAt', descending: true)
              .get();

      return query.docs
          .map((doc) => ChatConversation.fromFirestore(doc.data(), doc.id))
          .toList();
    } catch (e) {
    }
  }

  /// Stream all conversations for a user (real-time)
  Stream<List<ChatConversation>> streamUserConversations(String userId) {
    return _chatsRef
        .where('participantIds', arrayContains: userId)
        .where('isActive', isEqualTo: true)
        .orderBy('lastMessageAt', descending: true)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs
                  .map(
                    (doc) => ChatConversation.fromFirestore(doc.data(), doc.id),
                  .toList(),
  }

  /// Delete/deactivate a conversation
  Future<void> deleteConversation(String chatId) async {
    try {
      await _chatsRef.doc(chatId).update({
        'isActive': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
    }
  }

  // ============================================================================
  // MESSAGE OPERATIONS
  // ============================================================================

  /// Record a free-tier chat partner ONLY after a message is successfully sent.
  /// This guarantees: opening chats / failed sends do not consume free slots.
  Future<void> _recordFreeTierPartnerIfNeeded({
    required String senderId,
    required String receiverId,
  }) async {
    final meRef = _fs.collection('users').doc(senderId);
    final snap = await meRef.get();
    final data = snap.data();

    final chatMap = (data?['chat'] as Map?)?.cast<String, dynamic>();
    final rawList = chatMap?['freeChatPartnerIds'];
    final legacySingle = chatMap?['freeChatPartnerId'];

    final freeList = <String>[];
    if (rawList is List) {
      for (final v in rawList) {
        if (v is String && v.trim().isNotEmpty) freeList.add(v.trim());
      }
    }
    if (legacySingle is String && legacySingle.trim().isNotEmpty) {
      final v = legacySingle.trim();
      if (!freeList.contains(v)) freeList.add(v);
    }

    if (freeList.contains(receiverId)) return;

    // If already at limit, don't throw here â€” send already succeeded.
    if (freeList.length >= _kFreeChatPartnerLimit) return;

    freeList.add(receiverId);
    await meRef.set(
      <String, dynamic>{
        'chat': <String, dynamic>{'freeChatPartnerIds': freeList},
      },
      SetOptions(merge: true),
  }



  /// Send a text message
  Future<ChatMessage> sendMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String content,
    MessageType type = MessageType.text,
    Map<String, dynamic>? metadata,
  }) async {
    // Free-tier gating happens ONLY on send.
    await _enforceFreeTierOnSend(senderId: senderId, receiverId: receiverId);

    try {
      await _assertUsersNotDisabled([senderId, receiverId]);

      final messageRef = _messagesRef(chatId).doc();

      final message = ChatMessage(
        id: messageRef.id,
        chatId: chatId,
        senderId: senderId,
        receiverId: receiverId,
        content: content,
        type: type,
        sentAt: DateTime.now(),
        metadata: metadata,

      // Use batch for atomic operation
      final batch = _fs.batch();

      // Add message
      batch.set(messageRef, message.toFirestore());

      // Update conversation metadata
      batch.update(_chatsRef.doc(chatId), {
        'lastMessage':
            type == MessageType.text ? content : _getMessageTypePreview(type),
        'lastMessageAt': FieldValue.serverTimestamp(),
        'lastMessageSenderId': senderId,
        'unreadCounts.$receiverId': FieldValue.increment(1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      await batch.commit();
      await _recordFreeTierPartnerIfNeeded(
        senderId: senderId,
        receiverId: receiverId,
      return message;
    } catch (e) {
      // Preserve user-facing gating/errors.
      if (e is ChatException) rethrow;
      // Otherwise keep a generic error.
    }

  }

  String _getMessageTypePreview(MessageType type) {
    switch (type) {
      case MessageType.image:
        return 'ðŸ“· Photo';
      case MessageType.audio:
        return 'ðŸŽµ Voice message';
      case MessageType.video:
        return 'ðŸŽ¥ Video';
      case MessageType.file:
        return 'ðŸ“Ž File';
      case MessageType.system:
        return 'System message';
      default:
        return '';
    }
  }

  /// Send a quick text message (convenience method)
  Future<ChatMessage> sendTextMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String text,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: text,
      type: MessageType.text,
  }

  /// Send an image message
  Future<ChatMessage> sendImageMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String imageUrl,
    String? caption,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: imageUrl,
      type: MessageType.image,
      metadata: caption != null ? {'caption': caption} : null,
  }

  /// Send an audio message
  Future<ChatMessage> sendAudioMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String audioUrl,
    required int durationSeconds,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: audioUrl,
      type: MessageType.audio,
      metadata: {'duration': durationSeconds},
  }

  /// Get messages for a chat
  Future<List<ChatMessage>> getMessages(
    String chatId, {
    int limit = 50,
    DocumentSnapshot? startAfter,
  }) async {
    try {
      Query<Map<String, dynamic>> query = _messagesRef(
        chatId,
      ).orderBy('sentAt', descending: true).limit(limit);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      final snapshot = await query.get();

      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(doc.data(), doc.id))
          .toList();
    } catch (e) {
    }
  }

  /// Stream messages for a chat (real-time)
  Stream<List<ChatMessage>> streamMessages(String chatId, {int limit = 50}) {
    return _messagesRef(chatId)
        .orderBy('sentAt', descending: true)
        .limit(limit)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs
                  .map((doc) => ChatMessage.fromFirestore(doc.data(), doc.id))
                  .toList(),
  }

  /// Delete a message
  Future<void> deleteMessage(String chatId, String messageId) async {
    try {
      await _messagesRef(chatId).doc(messageId).delete();
    } catch (e) {
    }
  }

  // ============================================================================
  // READ STATUS
  // ============================================================================

  /// Mark messages as read
  Future<void> markMessagesAsRead(String chatId, String userId) async {
    try {
      // Update unread count in conversation
      await _chatsRef.doc(chatId).update({
        'unreadCounts.$userId': 0,
        'lastReadAt.$userId': FieldValue.serverTimestamp(),
      });

      // Optionally mark individual messages as read
      final unreadMessages =
          await _messagesRef(chatId)
              .where('receiverId', isEqualTo: userId)
              .where('isRead', isEqualTo: false)
              .get();

      if (unreadMessages.docs.isEmpty) return;

      final batch = _fs.batch();
      for (final doc in unreadMessages.docs) {
        batch.update(doc.reference, {
          'isRead': true,
          'readAt': FieldValue.serverTimestamp(),
        });
      }
      await batch.commit();
    } catch (e) {
      debugPrint('Error marking messages as read: $e');
    }
  }

  /// Get total unread count for a user across all chats
  Future<int> getTotalUnreadCount(String userId) async {
    try {
      final chats = await getUserConversations(userId);
      int total = 0;
      for (final chat in chats) {
        total += chat.getUnreadCount(userId);
      }
      return total;
    } catch (e) {
      return 0;
    }
  }

  /// Stream total unread count
  Stream<int> streamTotalUnreadCount(String userId) {
    return streamUserConversations(userId).map((chats) {
      int total = 0;
      for (final chat in chats) {
        total += chat.getUnreadCount(userId);
      }
      return total;
    });
  }

  // ============================================================================
  // TYPING INDICATORS (Optional)
  // ============================================================================

  /// Set typing status
  Future<void> setTypingStatus(
    String chatId,
    String userId,
    bool isTyping,
  ) async {
    try {
      await _chatsRef.doc(chatId).update({'typingUsers.$userId': isTyping});
    } catch (e) {
      debugPrint('Error setting typing status: $e');
    }
  }

  /// Stream typing users
  Stream<List<String>> streamTypingUsers(String chatId) {
    return _chatsRef.doc(chatId).snapshots().map((doc) {
      final data = doc.data();
      if (data == null) return <String>[];

      final typingUsers = data['typingUsers'] as Map<String, dynamic>? ?? {};
      return typingUsers.entries
          .where((e) => e.value == true)
          .map((e) => e.key)
          .toList();
    });
  }

  // ============================================================================
  // SEARCH & FILTERING
  // ============================================================================

  /// Search messages in a chat
  Future<List<ChatMessage>> searchMessages(
    String chatId,
    String query, {
    int limit = 20,
  }) async {
    try {
      // Note: Firestore doesn't support full-text search
      // This is a basic implementation - for production, use Algolia or similar
      final messages = await getMessages(chatId, limit: 200);

      final queryLower = query.toLowerCase();
      return messages
          .where((m) => m.content.toLowerCase().contains(queryLower))
          .take(limit)
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Exception for chat operations
}

class ChatException implements Exception {
  final String message;
  ChatException(this.message);

  @override
  String toString() => message;
}
