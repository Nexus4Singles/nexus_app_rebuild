import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nexus_app_min_test/core/auth/auth_providers.dart';
import 'package:nexus_app_min_test/core/dating/dating_profile_gate.dart';
import 'package:nexus_app_min_test/core/theme/theme.dart';
import 'package:nexus_app_min_test/core/widgets/guest_guard.dart';

class ChatThreadScreen extends ConsumerStatefulWidget {
  final String chatId;

  const ChatThreadScreen({super.key, required this.chatId});

  @override
  ConsumerState<ChatThreadScreen> createState() => _ChatThreadScreenState();
}

class _ChatThreadScreenState extends ConsumerState<ChatThreadScreen> {
  final _controller = TextEditingController();
  final _scroll = ScrollController();

  bool _isRecording = false;

  // Stub messages for now (UI first). Later we swap to providers.
  final List<_UiMessage> _messages = [
    _UiMessage(text: 'Hello ðŸ‘‹', isMe: false, timeLabel: '10:18'),
    _UiMessage(text: 'Hi!', isMe: true, timeLabel: '10:19'),
    _UiMessage(text: 'Thread UI is wired. Backend next.', isMe: false, timeLabel: '10:20'),
  ];

  @override
  void dispose() {
    _controller.dispose();
    _scroll.dispose();
    super.dispose();
  }

  bool get _canSendText => _controller.text.trim().isNotEmpty;

  Future<void> _ensureSignedInThen(BuildContext context, Future<void> Function() onAllowed) async {
    final authAsync = ref.read(authStateProvider);
    final isSignedIn = authAsync.maybeWhen(
      data: (a) => a.isSignedIn,
      orElse: () => false,
    );

    if (!isSignedIn) {
      GuestGuard.requireSignedIn(
        context,
        ref,
        title: 'Create an account to chat',
        message: 'You\'re currently in guest mode. Create an account to send messages, voice notes, and files.',
        primaryText: 'Create an account',
        onCreateAccount: () => Navigator.of(context).pushNamed('/signup'),
        onAllowed: () async {},
      );
      return;
    }

    await DatingProfileGate.requireCompleteProfile(
      context,
      ref,
      onAllowed: onAllowed,
    );
  }

  void _scrollToBottomSoon() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!_scroll.hasClients) return;
      _scroll.animateTo(
        0,
        duration: const Duration(milliseconds: 250),
        curve: Curves.easeOut,
      );
    });
  }

  Future<void> _sendText() async {
    final text = _controller.text.trim();
    if (text.isEmpty) return;

    await _ensureSignedInThen(context, () async {
      setState(() {
        _messages.insert(0, _UiMessage(text: text, isMe: true, timeLabel: 'now'));
      });
      _controller.clear();
      _scrollToBottomSoon();

      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Sent (stub). Wire to backend next.')),
      );
    });
  }

  Future<void> _openAttachSheet() async {
    await _ensureSignedInThen(context, () async {
      if (!mounted) return;
      showModalBottomSheet(
        context: context,
        backgroundColor: AppColors.surface,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        builder: (_) {
          return SafeArea(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 44,
                    height: 5,
                    decoration: BoxDecoration(
                      color: AppColors.border,
                      borderRadius: BorderRadius.circular(999),
                    ),
                  ),
                  const SizedBox(height: 12),
                  Row(
                    children: [
                      Text('Attach', style: AppTextStyles.titleLarge),
                      const Spacer(),
                      IconButton(
                        icon: const Icon(Icons.close),
                        onPressed: () => Navigator.of(context).pop(),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  _AttachTile(
                    icon: Icons.image_outlined,
                    title: 'Photo',
                    subtitle: 'Pick an image to send',
                    onTap: () {
                      Navigator.of(context).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('Photo picker (TODO). Add image_picker later.')),
                      );
                    },
                  ),
                  const SizedBox(height: 10),
                  _AttachTile(
                    icon: Icons.attach_file,
                    title: 'File',
                    subtitle: 'Attach a document',
                    onTap: () {
                      Navigator.of(context).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('File picker (TODO). Add file_picker later.')),
                      );
                    },
                  ),
                  const SizedBox(height: 10),
                  _AttachTile(
                    icon: Icons.mic_none,
                    title: 'Voice note',
                    subtitle: 'Record and send audio',
                    onTap: () {
                      Navigator.of(context).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text('Voice note (TODO). Add record plugin later.')),
                      );
                    },
                  ),
                ],
              ),
            ),
          );
        },
      );
    });
  }

  Future<void> _startOrStopRecording() async {
    await _ensureSignedInThen(context, () async {
      setState(() => _isRecording = !_isRecording);

      if (_isRecording) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Recordingâ€¦ (stub). Add record plugin later.')),
        );
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Recorded (stub). Send audio next.')),
        );
      }
    });
  }

  Future<void> _startAudioCall() async {
    await _ensureSignedInThen(context, () async {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Audio call (TODO). Needs WebRTC/signalling later.')),
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      backgroundColor: AppColors.background,
      appBar: AppBar(
        backgroundColor: AppColors.background,
        elevation: 0,
        titleSpacing: 0,
        title: Row(
          children: [
            const SizedBox(width: 8),
            _Avatar(label: widget.chatId),
            const SizedBox(width: 10),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('Chat', style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w800)),
                  Text(
                    widget.chatId,
                    style: theme.textTheme.bodySmall?.copyWith(color: AppColors.textMuted),
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            tooltip: 'Audio call',
            icon: const Icon(Icons.call_outlined),
            onPressed: _startAudioCall,
          ),
          const SizedBox(width: 4),
        ],
      ),
      body: Column(
        children: [
          // Messages (reverse list: newest at bottom visually)
          Expanded(
            child: ListView.builder(
              controller: _scroll,
              reverse: true,
              padding: const EdgeInsets.fromLTRB(14, 12, 14, 12),
              itemCount: _messages.length,
              itemBuilder: (context, index) {
                final m = _messages[index];
                return _Bubble(
                  text: m.text,
                  isMe: m.isMe,
                  timeLabel: m.timeLabel,
                );
              },
            ),
          ),

          // Composer
          _Composer(
            controller: _controller,
            isRecording: _isRecording,
            onTextChanged: () => setState(() {}),
            onAttach: _openAttachSheet,
            onMic: _startOrStopRecording,
            onSend: _canSendText ? _sendText : null,
          ),
        ],
      ),
    );
  }
}

class _Composer extends StatelessWidget {
  final TextEditingController controller;
  final bool isRecording;
  final VoidCallback onTextChanged;
  final VoidCallback onAttach;
  final VoidCallback onMic;
  final VoidCallback? onSend;

  const _Composer({
    required this.controller,
    required this.isRecording,
    required this.onTextChanged,
    required this.onAttach,
    required this.onMic,
    required this.onSend,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.fromLTRB(12, 10, 12, 12),
      decoration: BoxDecoration(
        color: AppColors.surface,
        border: Border(top: BorderSide(color: AppColors.border)),
      ),
      child: SafeArea(
        top: false,
        child: Row(
          children: [
            IconButton(
              tooltip: 'Attach',
              icon: const Icon(Icons.add_circle_outline),
              onPressed: onAttach,
            ),
            Expanded(
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                decoration: BoxDecoration(
                  color: AppColors.background,
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: AppColors.border),
                ),
                child: TextField(
                  controller: controller,
                  onChanged: (_) => onTextChanged(),
                  minLines: 1,
                  maxLines: 4,
                  decoration: const InputDecoration(
                    hintText: 'Messageâ€¦',
                    border: InputBorder.none,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              tooltip: isRecording ? 'Stop recording' : 'Record voice note',
              icon: Icon(isRecording ? Icons.stop_circle_outlined : Icons.mic_none),
              onPressed: onMic,
            ),
            IconButton(
              tooltip: 'Send',
              icon: const Icon(Icons.send),
              onPressed: onSend,
            ),
          ],
        ),
      ),
    );
  }
}

class _AttachTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String subtitle;
  final VoidCallback onTap;

  const _AttachTile({
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(16),
        child: Container(
          padding: const EdgeInsets.all(14),
          decoration: BoxDecoration(
            color: AppColors.background,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: AppColors.border),
          ),
          child: Row(
            children: [
              Container(
                width: 44,
                height: 44,
                decoration: BoxDecoration(
                  color: AppColors.primary.withOpacity(0.10),
                  borderRadius: BorderRadius.circular(14),
                ),
                child: Icon(icon, color: AppColors.primary),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: AppTextStyles.labelLarge),
                    const SizedBox(height: 3),
                    Text(subtitle, style: AppTextStyles.caption.copyWith(color: AppColors.textMuted)),
                  ],
                ),
              ),
              const Icon(Icons.chevron_right),
            ],
          ),
        ),
      ),
    );
  }
}

class _Bubble extends StatelessWidget {
  final String text;
  final bool isMe;
  final String timeLabel;

  const _Bubble({
    required this.text,
    required this.isMe,
    required this.timeLabel,
  });

  @override
  Widget build(BuildContext context) {
    final maxWidth = MediaQuery.of(context).size.width * 0.78;

    return Align(
      alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
      child: ConstrainedBox(
        constraints: BoxConstraints(maxWidth: maxWidth),
        child: Container(
          margin: const EdgeInsets.only(bottom: 10),
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: isMe ? AppColors.primary.withOpacity(0.14) : AppColors.surface,
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: AppColors.border),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Align(
                alignment: Alignment.centerLeft,
                child: Text(text, style: AppTextStyles.bodyMedium),
              ),
              const SizedBox(height: 6),
              Text(
                timeLabel,
                style: AppTextStyles.caption.copyWith(color: AppColors.textMuted),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _Avatar extends StatelessWidget {
  final String label;
  const _Avatar({required this.label});

  @override
  Widget build(BuildContext context) {
    final initials = label.isEmpty ? 'C' : label.substring(0, 1).toUpperCase();
    return Container(
      width: 38,
      height: 38,
      decoration: BoxDecoration(
        color: AppColors.primary.withOpacity(0.12),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: AppColors.border),
      ),
      alignment: Alignment.center,
      child: Text(
        initials,
        style: AppTextStyles.labelLarge.copyWith(color: AppColors.primary),
      ),
    );
  }
}

class _UiMessage {
  final String text;
  final bool isMe;
  final String timeLabel;

  const _UiMessage({
    required this.text,
    required this.isMe,
    required this.timeLabel,
  });
}
