import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';

/// Chat message model
class ChatMessage {
  final String id;
  final String chatId;
  final String senderId;
  final String receiverId;
  final String content;
  final MessageType type;
  final DateTime sentAt;
  final DateTime? readAt;
  final bool isRead;
  final Map<String, dynamic>? metadata;

  const ChatMessage({
    required this.id,
    required this.chatId,
    required this.senderId,
    required this.receiverId,
    required this.content,
    this.type = MessageType.text,
    required this.sentAt,
    this.readAt,
    this.isRead = false,
    this.metadata,
  });

  factory ChatMessage.fromFirestore(Map<String, dynamic> data, String id) {
    return ChatMessage(
      id: id,
      chatId: data['chatId'] as String? ?? '',
      senderId: data['senderId'] as String? ?? '',
      receiverId: data['receiverId'] as String? ?? '',
      content: data['content'] as String? ?? '',
      type: MessageType.fromString(data['type'] as String?),
      sentAt: (data['sentAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      readAt: (data['readAt'] as Timestamp?)?.toDate(),
      isRead: data['isRead'] as bool? ?? false,
      metadata: data['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'chatId': chatId,
      'senderId': senderId,
      'receiverId': receiverId,
      'content': content,
      'type': type.name,
      'sentAt': FieldValue.serverTimestamp(),
      'readAt': readAt != null ? Timestamp.fromDate(readAt!) : null,
      'isRead': isRead,
      'metadata': metadata,
    };
  }

  ChatMessage copyWith({
    String? id,
    String? chatId,
    String? senderId,
    String? receiverId,
    String? content,
    MessageType? type,
    DateTime? sentAt,
    DateTime? readAt,
    bool? isRead,
    Map<String, dynamic>? metadata,
  }) {
    return ChatMessage(
      id: id ?? this.id,
      chatId: chatId ?? this.chatId,
      senderId: senderId ?? this.senderId,
      receiverId: receiverId ?? this.receiverId,
      content: content ?? this.content,
      type: type ?? this.type,
      sentAt: sentAt ?? this.sentAt,
      readAt: readAt ?? this.readAt,
      isRead: isRead ?? this.isRead,
      metadata: metadata ?? this.metadata,
    );
  }
}

enum MessageType {
  text,
  image,
  audio,
  video,
  file,
  system;

  static MessageType fromString(String? value) {
    return MessageType.values.firstWhere(
      (e) => e.name == value,
      orElse: () => MessageType.text,
    );
  }
}

/// Chat conversation model (metadata for a chat between two users)
class ChatConversation {
  final String id;
  final List<String> participantIds;
  final String? lastMessage;
  final DateTime? lastMessageAt;
  final String? lastMessageSenderId;
  final Map<String, int> unreadCounts;
  final Map<String, DateTime?> lastReadAt;
  final DateTime createdAt;
  final DateTime? updatedAt;
  final bool isActive;

  const ChatConversation({
    required this.id,
    required this.participantIds,
    this.lastMessage,
    this.lastMessageAt,
    this.lastMessageSenderId,
    this.unreadCounts = const {},
    this.lastReadAt = const {},
    required this.createdAt,
    this.updatedAt,
    this.isActive = true,
  });

  factory ChatConversation.fromFirestore(Map<String, dynamic> data, String id) {
    return ChatConversation(
      id: id,
      participantIds: List<String>.from(data['participantIds'] ?? []),
      lastMessage: data['lastMessage'] as String?,
      lastMessageAt: (data['lastMessageAt'] as Timestamp?)?.toDate(),
      lastMessageSenderId: data['lastMessageSenderId'] as String?,
      unreadCounts: Map<String, int>.from(data['unreadCounts'] ?? {}),
      lastReadAt:
          (data['lastReadAt'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, (value as Timestamp?)?.toDate()),
          ) ??
          {},
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate(),
      isActive: data['isActive'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'participantIds': participantIds,
      'lastMessage': lastMessage,
      'lastMessageAt':
          lastMessageAt != null ? Timestamp.fromDate(lastMessageAt!) : null,
      'lastMessageSenderId': lastMessageSenderId,
      'unreadCounts': unreadCounts,
      'lastReadAt': lastReadAt.map(
        (key, value) =>
            MapEntry(key, value != null ? Timestamp.fromDate(value) : null),
      ),
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': FieldValue.serverTimestamp(),
      'isActive': isActive,
    };
  }

  /// Get the other participant's ID
  String getOtherParticipantId(String currentUserId) {
    return participantIds.firstWhere(
      (id) => id != currentUserId,
      orElse: () => '',
    );
  }

  /// Get unread count for a user
  int getUnreadCount(String userId) {
    return unreadCounts[userId] ?? 0;
  }
}

/// Service for managing chat functionality
class ChatService {
  
  // ============================================================================
  // PREMIUM GATING (v2)
  // ============================================================================
  //
  // Requirement:
  // - Free users can chat with only ONE person.
  // - Starting chats with additional people requires Premium.
  //
  // Premium detection: checks common boolean fields on /users/{uid}.
  // If your real field differs, rename here.
  Future<bool> _isPremiumUser(String uid) async {
    try {
      final doc = await _fs.collection('users').doc(uid).get();
      final data = doc.data();
      if (data == null) return false;

      bool flag(String k) => (data[k] == true);

      return flag('isPremium') ||
          flag('premium') ||
          flag('subscriptionActive') ||
          flag('hasActiveSubscription');
    } catch (_) {
      // Fail-closed: treat as not premium.
      return false;
    }
  }

  Future<void> _enforceOneFreeChatPartner({
    required String initiatorId,
    required String otherUserId,
  }) async {
    final isPremium = await _isPremiumUser(initiatorId);
    if (isPremium) return;

    // If a conversation already exists with this other user, allow.
    // (Caller should also check existingChat, but we allow here too.)
    final existing = await getConversationBetween(initiatorId, otherUserId);
    if (existing != null) return;

    // Count distinct "other participants" for initiator in nexus2_chats.
    // If initiator already has at least 1 other participant, block starting a new one.
    final snap = await _chatsRef
        .where('participantIds', arrayContains: initiatorId)
        .limit(20)
        .get();

    final others = <String>{};
    for (final d in snap.docs) {
      final data = d.data();
      final parts = (data['participantIds'] as List?)?.map((e) => e.toString()).toList() ?? const <String>[];
      for (final p in parts) {
        if (p != initiatorId) others.add(p);
      }
      if (others.length >= 1) break;
    }

    // Free-tier rule: already chatted with 1 person => cannot start new chats.
    if (others.isNotEmpty) {
      throw StateError(
        'Premium required: you can chat with only one person for free. Upgrade to chat with more people.',
      );
    }
  }

FirebaseFirestore? _firestore;

  FirebaseFirestore get _fs =>
      _firestore ?? (throw StateError('Firestore not ready'));
  ChatService({FirebaseFirestore? firestore}) : _firestore = firestore;

  

  void _logFs(String stage, Object e, StackTrace st, Map<String, Object?> ctx) {
    // Deterministic logging to identify why Firestore denies an operation.
    // Keep this in debug builds; remove/reduce before release if needed.
    try {
      final prefix = '[CHAT][FS][$stage]';
      // cloud_firestore typically throws FirebaseException.
      final code = (e is FirebaseException) ? e.code : 'unknown';
      final msg = (e is FirebaseException) ? (e.message ?? '') : '';
      final plugin = (e is FirebaseException) ? e.plugin : 'unknown';
      debugPrint('$prefix code=$code plugin=$plugin message=$msg');
      debugPrint('$prefix ctx=$ctx');
      debugPrint('$prefix error=$e');
      debugPrint('$prefix stack=${st.toString().split('\n').take(12).join('\n')}');
    } catch (_) {
      // Never let logging break chat flows.
    }
  }
// Collection references
  CollectionReference<Map<String, dynamic>> get _chatsRef =>
      _fs.collection('nexus2_chats');

  CollectionReference<Map<String, dynamic>> _messagesRef(String chatId) =>
      _chatsRef.doc(chatId).collection('messages');

  // ============================================================================
  // ACCOUNT DISABLED GUARDS
  // ============================================================================
  Future<bool> _isUserDisabled(String uid) async {
    final doc = await _fs.collection('users').doc(uid).get();
    final data = doc.data();
    if (data == null) return false;

    // v2 canonical disable flag
    final account = (data['account'] is Map) ? (data['account'] as Map) : null;
    final isDisabled = account?['isDisabled'];
    if (isDisabled == true) return true;

    // Legacy fallbacks (safe for older docs)
    final accountStatus = data['accountStatus']?.toString().toLowerCase();
    if (accountStatus == 'disabled') return true;

    final status = data['status']?.toString().toLowerCase();
    if (status == 'disabled') return true;

    final disabled = data['disabled'];
    if (disabled == true) return true;

    return false;
  }

  Future<void> _assertUsersNotDisabled(List<String> uids) async {
    for (final uid in uids) {
      if (await _isUserDisabled(uid)) {
        throw ChatException('Account disabled by admin');
      }
    }
  }

  Future<void> _assertCanStartNewChat(String currentUserId) async {
    // Legacy v1 users may not have dating.verificationStatus -> allow by default.
    final doc = await _fs.collection('users').doc(currentUserId).get();
    final data = doc.data();
    final dating = (data?['dating'] as Map?)?.cast<String, dynamic>();
    final status = dating?['verificationStatus']?.toString();

    // Allow: verified OR null/missing (legacy)
    if (status == null || status.isEmpty || status == 'verified') return;

    // Block creating NEW chats while pending or rejected.
    if (status == 'pending') {
      throw ChatException(
        'Your dating profile is under review. You can chat in existing conversations, but you canâ€™t start new ones yet.',
      );
    }
    if (status == 'rejected') {
      throw ChatException(
        'Your dating profile is not verified. Please update your profile and re-submit for verification to start new chats.',
      );
    }

    // Unknown status -> be safe and allow (avoid accidentally blocking users).
    return;
  }

  // ============================================================================

  // ============================================================================
  // GENDER GUARDS
  // ============================================================================
  String? _normalizeGender(dynamic value) {
    final s = value?.toString().trim().toLowerCase();
    if (s == null || s.isEmpty) return null;

    // Accept v1/v2 variants by normalization.
    if (s == 'male') return 'male';
    if (s == 'female') return 'female';

    return null;
  }

  Future<void> _assertOppositeGender(String userId1, String userId2) async {
    final d1 = await _fs.collection('users').doc(userId1).get();
    final d2 = await _fs.collection('users').doc(userId2).get();

    final m1 = d1.data();
    final m2 = d2.data();

    // v1 stores gender at root: users/{uid}.gender (often "Male"/"Female")
    final g1 = _normalizeGender(m1?['gender']);
    final g2 = _normalizeGender(m2?['gender']);

    final isOpposite =
        (g1 == 'male' && g2 == 'female') || (g1 == 'female' && g2 == 'male');

    // Strict product rule: only male<->female chats are allowed.
    // Unknown/missing genders are rejected.
    if (!isOpposite) {
      throw ChatException(
        'You can only start chats with users of the opposite gender.',
      );
    }
  }

  // CONVERSATION MANAGEMENT
  // ============================================================================

  /// Create a new chat conversation between two users
  /// Returns the chat ID
  Future<String> createConversation(String userId1, String userId2) async {
    // Ensure consistent ordering for IDs and for a stable chatId.
    final a = userId1.trim();
    final b = userId2.trim();
    if (a.isEmpty || b.isEmpty) {
      throw ChatException('Missing participant id(s).');
    }
    if (a == b) {
      throw ChatException('You cannot start a chat with yourself.');
    }

    // Guards (keep these unless you intentionally remove them later).
    await _assertUsersNotDisabled([a, b]);
    await _assertCanStartNewChat(a);
    await _assertOppositeGender(a, b);
    await _enforceOneFreeChatPartner(initiatorId: userId1, otherUserId: userId2);

    // Check if conversation already exists
    final existingChat = await getConversationBetween(a, b);
    if (existingChat != null) return existingChat.id;

    final ids = <String>[a, b]..sort();
    final chatId = '${ids[0]}_${ids[1]}';

    final chatDoc = <String, dynamic>{
      // REQUIRED by Firestore rules (hasTwoParticipants + hasAny(auth.uid))
      'participantIds': ids,

      // Useful metadata
      'createdAt': FieldValue.serverTimestamp(),
      'updatedAt': FieldValue.serverTimestamp(),
      'lastMessageAt': FieldValue.serverTimestamp(),
      'lastMessagePreview': '',

      // Unread counts keyed by uid (safe default)
      'unreadCounts': <String, dynamic>{ids[0]: 0, ids[1]: 0},
    };

    try {
      try {
      await _chatsRef.doc(chatId).set(chatDoc, SetOptions(merge: false));
    } catch (e) {
      debugPrint('Error creating/updating chatDoc chatId=$chatId ids=$ids a=$a b=$b err=$e');
      if (e is FirebaseException) {
        debugPrint('Firestore code=${e.code} message=${e.message}');
      }
      rethrow;
    }
} catch (e, st) {
      _logFs(
        'createConversation:setChatDoc',
        e,
        st,
        <String, Object?>{
          'userId1': a,
          'userId2': b,
          'sortedIds': ids,
          'chatId': chatId,
          'docKeys': chatDoc.keys.toList(),
          'participantIds': chatDoc['participantIds'],
        },
      );
      rethrow;
    }
    return chatId;
  }

  /// Get conversation between two users
  Future<ChatConversation?> getConversationBetween(
    String userId1,
    String userId2,
  ) async {
    try {
            final a = userId1.trim();
      final b = userId2.trim();
      if (a.isEmpty || b.isEmpty) return null;

      // Deterministic v2 chat id (avoid query/list permission issues).
      final ids = <String>[a, b]..sort();
      final chatId = '${ids[0]}_${ids[1]}';

      final doc = await _chatsRef.doc(chatId).get();
      if (!doc.exists || doc.data() == null) return null;

      return ChatConversation.fromFirestore(doc.data()!, doc.id);

    } catch (e) {
      debugPrint('Error getting conversationBetween: $e');
      if (e is FirebaseException) {
        debugPrint('Firestore code=${e.code} message=${e.message}');
      }
      return null;
    }
  }

  /// Get conversation by ID
  Future<ChatConversation?> getConversation(String chatId) async {
    try {
      final doc = await _chatsRef.doc(chatId).get();
      if (!doc.exists || doc.data() == null) return null;
      return ChatConversation.fromFirestore(doc.data()!, doc.id);
    } catch (e) {
      debugPrint('Error getting conversationBetween: $e');
      if (e is FirebaseException) {
        debugPrint('Firestore code=${e.code} message=${e.message}');
      }
      return null;
    }
  }

  /// Get all conversations for a user
  Future<List<ChatConversation>> getUserConversations(String userId) async {
    try {
      final query =
          await _chatsRef
              .where('participantIds', arrayContains: userId)
              .where('isActive', isEqualTo: true)
              .orderBy('lastMessageAt', descending: true)
              .get();

      return query.docs
          .map((doc) => ChatConversation.fromFirestore(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw ChatException('Failed to get conversations: $e');
    }
  }

  /// Stream all conversations for a user (real-time)
  Stream<List<ChatConversation>> streamUserConversations(String userId) {
    return _chatsRef
        .where('participantIds', arrayContains: userId)
        .where('isActive', isEqualTo: true)
        .orderBy('lastMessageAt', descending: true)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs
                  .map(
                    (doc) => ChatConversation.fromFirestore(doc.data(), doc.id),
                  )
                  .toList(),
        );
  }

  /// Delete/deactivate a conversation
  Future<void> deleteConversation(String chatId) async {
    try {
      await _chatsRef.doc(chatId).update({
        'isActive': false,
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      throw ChatException('Failed to delete conversation: $e');
    }
  }

  // ============================================================================
  // MESSAGE OPERATIONS
  // ============================================================================

  /// Send a text message
  Future<ChatMessage> sendMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String content,
    MessageType type = MessageType.text,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      await _assertUsersNotDisabled([senderId, receiverId]);

      final messageRef = _messagesRef(chatId).doc();

      final message = ChatMessage(
        id: messageRef.id,
        chatId: chatId,
        senderId: senderId,
        receiverId: receiverId,
        content: content,
        type: type,
        sentAt: DateTime.now(),
        metadata: metadata,
      );

      // Use batch for atomic operation
      final batch = _fs.batch();

      // Add message
      batch.set(messageRef, message.toFirestore());

      // Update conversation metadata
      batch.update(_chatsRef.doc(chatId), {
        'lastMessage':
            type == MessageType.text ? content : _getMessageTypePreview(type),
        'lastMessageAt': FieldValue.serverTimestamp(),
        'lastMessageSenderId': senderId,
        'unreadCounts.$receiverId': FieldValue.increment(1),
        'updatedAt': FieldValue.serverTimestamp(),
      });

      await batch.commit();
      return message;
    } catch (e) {
      throw ChatException('Failed to send message: $e');
    }
  }

  String _getMessageTypePreview(MessageType type) {
    switch (type) {
      case MessageType.image:
        return 'ðŸ“· Photo';
      case MessageType.audio:
        return 'ðŸŽµ Voice message';
      case MessageType.video:
        return 'ðŸŽ¥ Video';
      case MessageType.file:
        return 'ðŸ“Ž File';
      case MessageType.system:
        return 'System message';
      default:
        return '';
    }
  }

  /// Send a quick text message (convenience method)
  Future<ChatMessage> sendTextMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String text,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: text,
      type: MessageType.text,
    );
  }

  /// Send an image message
  Future<ChatMessage> sendImageMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String imageUrl,
    String? caption,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: imageUrl,
      type: MessageType.image,
      metadata: caption != null ? {'caption': caption} : null,
    );
  }

  /// Send an audio message
  Future<ChatMessage> sendAudioMessage({
    required String chatId,
    required String senderId,
    required String receiverId,
    required String audioUrl,
    required int durationSeconds,
  }) async {
    return sendMessage(
      chatId: chatId,
      senderId: senderId,
      receiverId: receiverId,
      content: audioUrl,
      type: MessageType.audio,
      metadata: {'duration': durationSeconds},
    );
  }

  /// Get messages for a chat
  Future<List<ChatMessage>> getMessages(
    String chatId, {
    int limit = 50,
    DocumentSnapshot? startAfter,
  }) async {
    try {
      Query<Map<String, dynamic>> query = _messagesRef(
        chatId,
      ).orderBy('sentAt', descending: true).limit(limit);

      if (startAfter != null) {
        query = query.startAfterDocument(startAfter);
      }

      final snapshot = await query.get();

      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(doc.data(), doc.id))
          .toList();
    } catch (e) {
      throw ChatException('Failed to get messages: $e');
    }
  }

  /// Stream messages for a chat (real-time)
  Stream<List<ChatMessage>> streamMessages(String chatId, {int limit = 50}) {
    return _messagesRef(chatId)
        .orderBy('sentAt', descending: true)
        .limit(limit)
        .snapshots()
        .map(
          (snapshot) =>
              snapshot.docs
                  .map((doc) => ChatMessage.fromFirestore(doc.data(), doc.id))
                  .toList(),
        );
  }

  /// Delete a message
  Future<void> deleteMessage(String chatId, String messageId) async {
    try {
      await _messagesRef(chatId).doc(messageId).delete();
    } catch (e) {
      throw ChatException('Failed to delete message: $e');
    }
  }

  // ============================================================================
  // READ STATUS
  // ============================================================================

  /// Mark messages as read
  Future<void> markMessagesAsRead(String chatId, String userId) async {
    try {
      // Update unread count in conversation
      await _chatsRef.doc(chatId).update({
        'unreadCounts.$userId': 0,
        'lastReadAt.$userId': FieldValue.serverTimestamp(),
      });

      // Optionally mark individual messages as read
      final unreadMessages =
          await _messagesRef(chatId)
              .where('receiverId', isEqualTo: userId)
              .where('isRead', isEqualTo: false)
              .get();

      if (unreadMessages.docs.isEmpty) return;

      final batch = _fs.batch();
      for (final doc in unreadMessages.docs) {
        batch.update(doc.reference, {
          'isRead': true,
          'readAt': FieldValue.serverTimestamp(),
        });
      }
      await batch.commit();
    } catch (e) {
      debugPrint('Error marking messages as read: $e');
    }
  }

  /// Get total unread count for a user across all chats
  Future<int> getTotalUnreadCount(String userId) async {
    try {
      final chats = await getUserConversations(userId);
      int total = 0;
      for (final chat in chats) {
        total += chat.getUnreadCount(userId);
      }
      return total;
    } catch (e) {
      return 0;
    }
  }

  /// Stream total unread count
  Stream<int> streamTotalUnreadCount(String userId) {
    return streamUserConversations(userId).map((chats) {
      int total = 0;
      for (final chat in chats) {
        total += chat.getUnreadCount(userId);
      }
      return total;
    });
  }

  // ============================================================================
  // TYPING INDICATORS (Optional)
  // ============================================================================

  /// Set typing status
  Future<void> setTypingStatus(
    String chatId,
    String userId,
    bool isTyping,
  ) async {
    try {
      await _chatsRef.doc(chatId).update({'typingUsers.$userId': isTyping});
    } catch (e) {
      debugPrint('Error setting typing status: $e');
    }
  }

  /// Stream typing users
  Stream<List<String>> streamTypingUsers(String chatId) {
    return _chatsRef.doc(chatId).snapshots().map((doc) {
      final data = doc.data();
      if (data == null) return <String>[];

      final typingUsers = data['typingUsers'] as Map<String, dynamic>? ?? {};
      return typingUsers.entries
          .where((e) => e.value == true)
          .map((e) => e.key)
          .toList();
    });
  }

  // ============================================================================
  // SEARCH & FILTERING
  // ============================================================================

  /// Search messages in a chat
  Future<List<ChatMessage>> searchMessages(
    String chatId,
    String query, {
    int limit = 20,
  }) async {
    try {
      // Note: Firestore doesn't support full-text search
      // This is a basic implementation - for production, use Algolia or similar
      final messages = await getMessages(chatId, limit: 200);

      final queryLower = query.toLowerCase();
      return messages
          .where((m) => m.content.toLowerCase().contains(queryLower))
          .take(limit)
          .toList();
    } catch (e) {
      return [];
    }
  }
}

/// Exception for chat operations
class ChatException implements Exception {
  final String message;
  ChatException(this.message);

  @override
  String toString() => 'ChatException: $message';
}
